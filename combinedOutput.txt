
// File: /apps/api/src/app.module.ts
import { Module } from "@nestjs/common";
import { ConfigModule } from "@nestjs/config";
import { JwtModule } from "@nestjs/jwt";

import { ConversationService } from "./application/services/conversation.service";
import { AuthController } from "./auth/auth.controller";
import { AuthService } from "./auth/auth.service";
import { JwtStrategy } from "./auth/jwt.strategy";
import { SupabaseService } from "./chat/supabase.service";
import { CONVERSATION_REPOSITORY } from "./domain/conversation/repositories/conversation.repository";
import { SupabaseConversationRepository } from "./infrastructure/database/supabase/conversation.repository";
import { ChatController } from "./interfaces/http/chat.controller";
import { ChatGateway } from "./interfaces/websocket/chat.gateway";
import { CqrsModule } from "@nestjs/cqrs";
import { USER_REPOSITORY } from "./domain/user/repositiories/user.repository";
import { MESSAGE_REPOSITORY } from "./domain/messages/repositories/message.repository";
import { SupabaseMessageRepository } from "./infrastructure/database/supabase/message.repository";
import { SupabaseUserRepository } from "./infrastructure/database/supabase/user.repository";
import { SendMessageHandler } from "./application/commands/handlers/send-message.handler";
import { MessageSentHandler } from "./application/events/handlers/message-sent.handler";

const CommandHandlers = [SendMessageHandler];
const EventHandlers = [MessageSentHandler];

@Module({
  imports: [
    CqrsModule,
    JwtModule.register({
      secret: "your-secret-key",
      signOptions: { expiresIn: "1h" },
    }),
    ConfigModule.forRoot({
      isGlobal: true,
    }),
  ],
  controllers: [AuthController, ChatController],
  providers: [
    ...CommandHandlers,
    ...EventHandlers,
    ConversationService,
    ChatGateway,
    AuthService,
    JwtStrategy,
    SupabaseService,
    SupabaseConversationRepository,
    SupabaseMessageRepository,
    SupabaseUserRepository,
    {
      provide: CONVERSATION_REPOSITORY,
      useClass: SupabaseConversationRepository,
    },
    {
      provide: USER_REPOSITORY,
      useClass: SupabaseUserRepository,
    },
    {
      provide: MESSAGE_REPOSITORY,
      useClass: SupabaseMessageRepository,
    },
  ],
})
export class AppModule {}


// File: /apps/api/src/application/commands/handlers/send-message.handler.ts
import { Injectable, Logger, Inject } from "@nestjs/common";
import { CommandHandler, EventBus, ICommandHandler } from "@nestjs/cqrs";

import { ConversationRepository, CONVERSATION_REPOSITORY } from "../../../domain/conversation/repositories/conversation.repository";
import { ConversationId } from "../../../domain/conversation/value-objects/conversation-id";
import { Message } from "../../../domain/messages/entities/message.entity";
import { MessageRepository, MESSAGE_REPOSITORY } from "../../../domain/messages/repositories/message.repository";
import { MessageContent } from "../../../domain/messages/value-objects/message-content";
import { MessageId } from "../../../domain/messages/value-objects/message-id";
import { MessageStatus } from "../../../domain/messages/value-objects/message-status";
import { UserRepository, USER_REPOSITORY } from "../../../domain/user/repositiories/user.repository";
import { UserId } from "../../../domain/user/value-objects/user-id";
import { ChatGateway } from "../../../interfaces/websocket/chat.gateway";
import { SendMessageCommand } from "../send-message.command";
import { MessageSentEvent } from "../../events/message-sent.event";
@Injectable()
@CommandHandler(SendMessageCommand)
export class SendMessageHandler implements ICommandHandler<SendMessageCommand> {
  private readonly logger = new Logger(SendMessageHandler.name);

  constructor(
    @Inject(MESSAGE_REPOSITORY)
    private readonly messageRepository: MessageRepository,
    @Inject(CONVERSATION_REPOSITORY)
    private readonly conversationRepository: ConversationRepository,
    @Inject(USER_REPOSITORY)
    private readonly userRepository: UserRepository,
    private readonly eventBus: EventBus,
    private readonly chatGateway: ChatGateway,
  ) {}

  async execute(command: SendMessageCommand): Promise<void> {
    try {
      this.logger.debug(`Processing SendMessageCommand: ${JSON.stringify(command)}`);

      const sender = await this.userRepository.findById(new UserId(command.senderId));
      if (!sender) {
        throw new Error("Sender not found");
      }

      const message = new Message(
        MessageId.generate(),
        sender,
        new ConversationId(command.conversationId),
        new MessageContent(command.content),
        MessageStatus.create("SENT"),
        command.timestamp,
      );

      const savedMessage = await this.messageRepository.save(message);

      // Publish MessageSentEvent
      await this.eventBus.publish(
        new MessageSentEvent(
          {
            id: savedMessage.getId().toString(),
            content: savedMessage.getContent(),
            senderId: sender.getId(),
            conversationId: command.conversationId,
            createdAt: savedMessage.getCreatedAt(),
            status: savedMessage.getStatus().getValue(),
          },
          {
            id: sender.getId(),
            name: sender.getName(),
            profilePhotoUrl: sender.getProfilePhotoUrl(),
          },
        ),
      );

      this.logger.debug("Message sent and event published successfully");
    } catch (error) {
      this.logger.error(`Failed to process send message command: ${error.message}`);
      throw error;
    }
  }
}


// File: /apps/api/src/application/commands/send-message.command.ts
export class SendMessageCommand {
  constructor(
    public readonly content: string,
    public readonly senderId: string,
    public readonly conversationId: string,
    public readonly timestamp: Date = new Date(),
  ) {}
}


// File: /apps/api/src/application/events/handlers/message-sent.handler.ts
import { Inject, Injectable, Logger } from "@nestjs/common";
import { EventsHandler, IEventHandler } from "@nestjs/cqrs";

import { CONVERSATION_REPOSITORY, ConversationRepository } from "../../../domain/conversation/repositories/conversation.repository";
import { ConversationId } from "../../../domain/conversation/value-objects/conversation-id";
import { ChatGateway } from "../../../interfaces/websocket/chat.gateway";
import { MessageSentEvent } from "../message-sent.event";

@Injectable()
@EventsHandler(MessageSentEvent)
export class MessageSentHandler implements IEventHandler<MessageSentEvent> {
  private readonly logger = new Logger(MessageSentHandler.name);

  constructor(
    @Inject(CONVERSATION_REPOSITORY)
    private readonly conversationRepository: ConversationRepository,
    private readonly chatGateway: ChatGateway,
  ) {}

  async handle(event: MessageSentEvent): Promise<void> {
    try {
      this.logger.debug(`Handling MessageSentEvent: ${JSON.stringify(event)}`);

      await this.conversationRepository.updateLastMessage(new ConversationId(event.message.conversationId), {
        messageId: event.message.id,
        content: event.message.content,
        senderId: event.message.senderId,
        timestamp: event.message.createdAt,
      });

      const participants = await this.conversationRepository.getParticipants(event.message.conversationId);

      for (const userId of participants) {
        const conversations = await this.conversationRepository.getUserConversations(userId);

        this.chatGateway.emitToUser(userId, "loadConversationListSuccess", conversations);
        this.chatGateway.emitToUser(userId, "sendMessageSuccess", {
          ...event.message,
          sender: event.sender,
        });
      }

      this.logger.debug("Message sent event handled successfully");
    } catch (error) {
      this.logger.error(`Failed to handle message sent event: ${error.message}`);
      throw error;
    }
  }
}


// File: /apps/api/src/application/events/message-sent.event.ts
export class MessageSentEvent {
  constructor(
    public readonly message: {
      id: string;
      content: string;
      senderId: string;
      conversationId: string;
      createdAt: Date;
      status: string;
    },
    public readonly sender: {
      id: string;
      name: string;
      profilePhotoUrl?: string;
    },
  ) {}
}


// File: /apps/api/src/application/services/conversation.service.ts
import { ConversationDetailsDto, ConversationListElementDto } from "@chat-app/dtos";
import { Inject, Injectable } from "@nestjs/common";

import { CONVERSATION_REPOSITORY, ConversationRepository } from "../../domain/conversation/repositories/conversation.repository";
import { ConversationId } from "../../domain/conversation/value-objects/conversation-id";
import { MESSAGE_REPOSITORY, MessageRepository } from "../../domain/messages/repositories/message.repository";

@Injectable()
export class ConversationService {
  constructor(
    @Inject(CONVERSATION_REPOSITORY) private conversationRepository: ConversationRepository,
    @Inject(MESSAGE_REPOSITORY) private messageRepository: MessageRepository,
  ) {}

  async getUserConversations(userId: string): Promise<ConversationListElementDto[]> {
    console.log("YYYYYYY");
    return await this.conversationRepository.getUserConversations(userId);
  }

  async getConversationDetails(userId: string, conversationId: string): Promise<ConversationDetailsDto> {
    const conversationIdVO = new ConversationId(conversationId);
    // todo it should be more clear like return conversation then get messages etc now it is dirty
    const conversationDetails = await this.conversationRepository.findById(conversationIdVO);

    return {
      conversationId: conversationDetails.conversationId,
      messageList: conversationDetails.messageList,
      memberList: conversationDetails.memberList,
    };
  }
}


// File: /apps/api/src/application/services/message.service.ts
import { Injectable, Logger } from "@nestjs/common";
import { CommandBus } from "@nestjs/cqrs";

import { ConversationRepository } from "../../domain/conversation/repositories/conversation.repository";
import { ConversationId } from "../../domain/conversation/value-objects/conversation-id";
import { Message } from "../../domain/messages/entities/message.entity";
import { MessageRepository } from "../../domain/messages/repositories/message.repository";
import { MessageContent } from "../../domain/messages/value-objects/message-content";
import { MessageId } from "../../domain/messages/value-objects/message-id";
import { MessageStatus, MessageStatusType } from "../../domain/messages/value-objects/message-status";
import { UserRepository } from "../../domain/user/repositiories/user.repository";
import { UserId } from "../../domain/user/value-objects/user-id";
import { SendMessageCommand } from "../commands/send-message.command";

export interface SendMessageDto {
  messageId?: string;
  content: string;
  senderId: string;
  conversationId: string;
  timestamp?: Date;
}

export interface GetMessagesDto {
  conversationId: string;
  limit?: number;
  before?: Date;
}

@Injectable()
export class MessageService {
  private readonly logger = new Logger(MessageService.name);

  constructor(
    private readonly messageRepository: MessageRepository,
    private readonly conversationRepository: ConversationRepository,
    private readonly userRepository: UserRepository,
    private readonly commandBus: CommandBus,
  ) {}

  async sendMessage(dto: SendMessageDto): Promise<Message> {
    try {
      // Validate sender exists
      const sender = await this.userRepository.findById(new UserId(dto.senderId));
      if (!sender) {
        throw new Error("Sender not found");
      }

      // Create message entity with proper value objects
      const message = new Message(
        dto.messageId ? new MessageId(dto.messageId) : MessageId.generate(),
        sender,
        new ConversationId(dto.conversationId),
        new MessageContent(dto.content),
        MessageStatus.create(MessageStatusType.SENT),
        dto.timestamp || new Date(),
      );

      // Save message through repository
      const savedMessage = await this.messageRepository.save(message);

      // Update conversation's last message
      await this.conversationRepository.updateLastMessage(new ConversationId(dto.conversationId), {
        messageId: savedMessage.getId().toString(),
        content: savedMessage.getContent(),
        senderId: sender.getId(),
        timestamp: savedMessage.getCreatedAt(),
      });

      return savedMessage;
    } catch (error) {
      this.logger.error(`Failed to send message: ${error.message}`);
      throw error;
    }
  }

  async getConversationMessages(dto: GetMessagesDto): Promise<Message[]> {
    try {
      const conversationId = new ConversationId(dto.conversationId);

      // Verify conversation exists
      const conversation = await this.conversationRepository.findById(conversationId);
      if (!conversation) {
        throw new Error("Conversation not found");
      }

      // Get messages from repository
      const messages = await this.messageRepository.findByConversationId(conversationId);

      return messages;
    } catch (error) {
      this.logger.error(`Failed to get conversation messages: ${error.message}`);
      throw error;
    }
  }
}


// File: /apps/api/src/auth/auth.controller.ts
import { Body, Controller, Post } from "@nestjs/common";

import { AuthService } from "./auth.service"; // Change this import

@Controller("auth")
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post("login")
  async login(@Body() loginDto: { username: string; password: string }) {
    return this.authService.login(loginDto);
  }
}


// File: /apps/api/src/auth/auth.service.ts
import { Injectable } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";

import { SupabaseService } from "../chat/supabase.service";

@Injectable()
export class AuthService {
  constructor(
    private jwtService: JwtService,
    private supa: SupabaseService,
  ) {}

  async login(loginDto: { username: string; password: string }) {
    return this.supa.login({ email: loginDto.username, password: loginDto.password });
  }
}


// File: /apps/api/src/auth/jwt-auth.guard.ts
import { Injectable } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";

@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {}


// File: /apps/api/src/auth/jwt.strategy.ts
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: "your-secret-key",
    });
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async validate(payload: any) {
    if (!payload || !payload.sub) {
      throw new UnauthorizedException("Invalid token payload");
    }

    return {
      id: payload.sub,
      username: payload.username,
    };
  }
}


// File: /apps/api/src/chat/chat.gateway.ts
// import { SendMessageRequestDto } from "@chat-app/dtos";
// import { Logger } from "@nestjs/common";
// import {
//   ConnectedSocket,
//   MessageBody,
//   OnGatewayConnection,
//   OnGatewayDisconnect,
//   SubscribeMessage,
//   WebSocketGateway,
//   WebSocketServer,
// } from "@nestjs/websockets";
// import { Server, Socket } from "socket.io";
//
// import { SupabaseService } from "./supabase.service";
//
// @WebSocketGateway({
//   cors: {
//     origin: "*",
//   },
// })
// export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {
//   @WebSocketServer() server: Server;
//   map = {
//     "1": "18cdf29a-2a91-4490-9b18-0d9c5bd4812c",
//   };
//   private logger = new Logger("ChatGateway");
//
//   constructor(private supabaseService: SupabaseService) {}
//
//   async handleConnection(client: Socket) {
//     try {
//       const userId = client.handshake.query.userId as string;
//       if (!userId) {
//         this.logger.error("User ID not provided in connection");
//         client.disconnect();
//         return;
//       }
//       client.join(`user:${userId}`);
//       this.logger.log(`Client connected: ${client.id} for user: ${userId}`);
//     } catch (error) {
//       this.logger.error(`Error in handleConnection: ${error.message}`);
//     }
//   }
//
//   async handleDisconnect(client: Socket) {
//     const userId = client.handshake.query.userId as string;
//     if (userId) {
//       client.leave(`user:${userId}`);
//       this.logger.log(`Client disconnected: ${client.id} for user: ${userId}`);
//     }
//   }
//
//   @SubscribeMessage("sendMessage")
//   // eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/no-unused-vars
//   async handleSendMessage(@MessageBody() requestDto: SendMessageRequestDto, @ConnectedSocket() client: Socket): Promise<void> {
//     await this.supabaseService.updateConversationList(requestDto);
//     const savedMessage = await this.supabaseService.saveMessage(requestDto);
//     const conversationUsers = await this.supabaseService.getUserIdListFromConversation(requestDto.conversationId);
//
//     for (const userId of conversationUsers) {
//       const conversations = await this.supabaseService.getConversationsByUserId(userId);
//       this.server.to(`user:${userId}`).emit("loadConversationListSuccess", conversations);
//       this.server.to(`user:${userId}`).emit("sendMessageSuccess", savedMessage);
//     }
//   }
//
//   async updateMessagesFromQueue(userId, conversationId, queue) {
//     for (const message of queue) {
//       await this.handleSendMessage(message, null);
//     }
//   }
// }


// File: /apps/api/src/chat/model/conversation.model.ts
export type MessageDbModel = {
  id: number;
  content: string;
  created_at: string;
  sender: {
    name: string;
    id: number;
    profile_photo_url: string | null;
  };
  conversation: {
    id: number;
    name: string;
    avatar_url: string;
    chat_type: string;
  };
};


// File: /apps/api/src/chat/supabase.service.ts
import { ConversationDetailsDto, ConversationListElementDto, MemberDto, MessageDto, SendMessageRequestDto } from "@chat-app/dtos";
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";
import { createClient, SupabaseClient } from "@supabase/supabase-js";

import { MessageDbModel } from "./model/conversation.model";

@Injectable()
export class SupabaseService {
  supabase: SupabaseClient;

  constructor(private jwtService: JwtService) {
    this.supabase = createClient(process.env.SUPABASE_URL, process.env.SUPABASE_KEY);
  }

  // async getConversationsByUserId(userId: string): Promise<ConversationListElementDto[]> {
  //   const { data } = await this.supabase
  //     .from('conversationuser')
  //     .select(`
  //           conversation_id,
  //           conversation:conversation_id(name, avatar_url, chat_type, last_message, last_message_timestamp, last_message_sender_id),
  //           other_user:conversation_id(users!inner(id, name, profile_photo_url))
  //       `)
  //     .eq('user_id', userId)
  //     .neq('other_user.users.id', userId);
  //
  //   return data.map((item: any) => {
  //     const isOneOnOne = item.conversation.chat_type === 'single';
  //
  //     return {
  //       conversationId: item.conversation_id,
  //       avatarUrl: isOneOnOne ? item.other_user.users[0].profile_photo_url : item.conversation.avatar_url,
  //       name: isOneOnOne ? item.other_user.users[0].name : item.conversation.name,
  //       chatType: item.conversation.chat_type,
  //       lastMessageContent: item.conversation.last_message,
  //       lastMessageTimestamp: item.conversation.last_message_timestamp,
  //       lastMessageSenderId: item.conversation.last_message_sender_id
  //     };
  //   }).sort((a, b) => b.lastMessageTimestamp.localeCompare(a.lastMessageTimestamp));
  // }

  async login(loginDto: { email: string; password: string }) {
    try {
      // Query the users table
      const { data: user } = await this.supabase
        .from("users")
        .select("id, name, email, profile_photo_url")
        .eq("email", loginDto.email)
        .eq("password", loginDto.password) // Note: In production, use proper password hashing
        .single();

      const payload = {
        email: user.email,
        sub: user.id,
        name: user.name,
        profile_photo_url: user.profile_photo_url,
      };

      return {
        access_token: this.jwtService.sign(payload),
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          profile_photo_url: user.profile_photo_url,
        },
      };
    } catch (error) {
      throw new UnauthorizedException("Invalid credentials");
    }
  }

  async getConversationsByUserId(userId: string): Promise<ConversationListElementDto[]> {
    try {
      const { data, error } = await this.supabase
        .from("conversationuser")
        .select(
          `
        conversation_id,
        conversation:conversation_id(
          name,
          avatar_url,
          last_message,
          last_message_timestamp
        ),
        other_user:conversation_id(users!inner(id, name, profile_photo_url)),
        last_message:conversation_id(
          message(sender_id)
        )
      `,
        )
        .eq("user_id", userId)
        .neq("other_user.users.id", userId)
        .order("conversation(last_message_timestamp)", { ascending: false });

      if (error) {
        return [];
      }

      if (!data || data.length === 0) {
        return [];
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const conversations: ConversationListElementDto[] = data.map((item: any) => {
        const otherUser = item.other_user.users[0];
        const lastMessage = item.last_message.message[0];

        return {
          conversationId: item.conversation_id,
          avatarUrl: otherUser?.profile_photo_url,
          name: otherUser?.name,
          lastMessageContent: item.conversation.last_message || "",
          lastMessageTimestamp: item.conversation.last_message_timestamp || "",
          lastMessageSenderId: lastMessage?.sender_id || "",
        };
      });
      return conversations;
    } catch (error) {
      return [];
    }
  }

  async saveMessage(message: SendMessageRequestDto): Promise<MessageDto> {
    const { data } = await this.supabase
      .from("message")
      .insert({
        conversation_id: message.conversationId,
        local_message_id: message.localMessageId,
        sender_id: message.userId,
        content: message.content,
        created_at: message.timestamp,
        status: "sent",
      })
      .select()
      .single();

    return data;
  }

  async getConversation(userId: string, conversationId: string): Promise<ConversationDetailsDto> {
    const data = await this.supabase
      .from("message")
      .select(
        `
              id,
              content,
              created_at,
              sender:users(name, id, profile_photo_url),
              conversation:conversation!inner(id)
            `,
      )
      .eq("conversation_id", conversationId)
      .order("created_at", { ascending: true });

    //TODO: check how to type objects from supabase etc.
    // const conversationListDb: ConversationDbModel[] = data as any;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const messageListDb: MessageDbModel[] = data.data as any;

    return {
      conversationId: conversationId,
      messageList: messageListDb.map((msg) => ({
        message_id: String(msg.id),
        content: msg.content,
        created_at: msg.created_at,
        sender_id: String(msg.sender.id),
        status: "sent", //todo
      })),
      memberList: this.getUniqueSenders(messageListDb),
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getUniqueSenders(data: any): MemberDto[] {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return Array.from(new Map(data.map((msg: any) => [msg.sender.id, msg.sender])).values()) as MemberDto[];
  }

  //todo remove after auth implementation
  async getAllUsers() {
    const { data } = await this.supabase.from("users").select("*");
    return data;
  }

  async updateConversationList(sendMessageDto: SendMessageRequestDto): Promise<void> {
    await this.supabase
      .from("conversation")
      .update({
        last_message: sendMessageDto.content,
        last_message_timestamp: sendMessageDto.timestamp,
        last_message_sender_id: sendMessageDto.userId,
      })
      .eq("id", sendMessageDto.conversationId);
  }

  async getUserIdListFromConversation(conversationId: string): Promise<string[]> {
    const { data } = await this.supabase.from("conversationuser").select("user_id").eq("conversation_id", conversationId);
    return data.map((item) => item.user_id);
  }

  async updateMessages(userId, conversationId, queue) {
    const { data } = await this.supabase
      .from("message")
      .upsert({
        conversation_id: conversationId,
        local_message_id: queue.localMessageId,
        sender_id: userId,
        content: queue.content,
        created_at: queue.timestamp,
        status: "sending",
      })
      .eq("conversation_id", conversationId)
      .eq("sender_id", userId);
    return data;
  }
}


// File: /apps/api/src/domain/conversation/entities/conversation.entity.ts
import { Message } from "../../messages/entities/message.entity";
import { User } from "../../user/entities/user.entity";
import { ConversationId } from "../value-objects/conversation-id";
import { ConversationType } from "../value-objects/conversation-type";

export class Conversation {
  private readonly id: ConversationId;
  private readonly name: string;
  private avatarUrl?: string;
  private readonly type: ConversationType;
  private readonly members: User[];
  private messages: Message[];
  private lastMessage?: Message;

  constructor(id: ConversationId, name: string, type: ConversationType, members: User[], avatarUrl?: string) {
    this.id = id;
    this.name = name;
    this.type = type;
    this.members = members;
    this.avatarUrl = avatarUrl;
    this.messages = [];
  }

  public addMessage(message: Message): void {
    this.messages.push(message);
    this.lastMessage = message;
  }

  public getId(): ConversationId {
    return this.id;
  }

  public getMembers(): User[] {
    return [...this.members];
  }

  public getLastMessage(): Message | undefined {
    return this.lastMessage;
  }

  public getAvatarUrl(): string | undefined {
    return this.avatarUrl;
  }

  public getLastMessageTimestamp(): Date | undefined {
    return this.lastMessage?.getCreatedAt();
  }

  public getLastMessageSenderId(): string | undefined {
    return this.lastMessage?.getSender().getId();
  }

  public getName(): string {
    if (this.type === ConversationType.DIRECT && this.members.length === 2) {
      const otherUser = this.members.find((member) => member.getId() !== this.members[0].getId());
      return otherUser?.getName() || this.name;
    }
    return this.name;
  }
}


// File: /apps/api/src/domain/conversation/repositories/conversation.repository.ts
import { ConversationDetailsDto, ConversationListElementDto } from "@chat-app/dtos";

import { Conversation } from "../entities/conversation.entity";
import { ConversationId } from "../value-objects/conversation-id";

export const CONVERSATION_REPOSITORY = "CONVERSATION_REPOSITORY";

export interface ConversationRepository {
  findById(id: ConversationId): Promise<ConversationDetailsDto>;
  getUserConversations(userId: string): Promise<ConversationListElementDto[]>; // Changed method name to match implementation
  save(conversation: Conversation): Promise<void>;
  update(conversation: Conversation): Promise<void>;
  updateLastMessage(
    conversationId: ConversationId,
    lastMessage: {
      messageId: string;
      content: string;
      senderId: string;
      timestamp: Date;
    },
  ): Promise<void>;
  getParticipants(conversationId: string): Promise<string[]>;
}


// File: /apps/api/src/domain/conversation/value-objects/conversation-id.ts
export class ConversationId {
  constructor(private readonly value: string) {
    if (!value) {
      throw new Error("Conversation ID cannot be empty");
    }
  }

  public getValue(): string {
    return this.value;
  }
}


// File: /apps/api/src/domain/conversation/value-objects/conversation-type.ts
export enum ConversationType {
  DIRECT = "direct",
  GROUP = "group",
}


// File: /apps/api/src/domain/messages/entities/message.entity.ts
import { ConversationId } from "../../conversation/value-objects/conversation-id";
import { User } from "../../user/entities/user.entity";
import { MessageContent } from "../value-objects/message-content";
import { MessageId } from "../value-objects/message-id";
import { MessageStatus } from "../value-objects/message-status";

export class Message {
  constructor(
    private readonly id: MessageId,
    private readonly sender: User,
    private readonly conversationId: ConversationId,
    private content: MessageContent,
    private status: MessageStatus,
    private readonly createdAt: Date,
  ) {}

  public getId(): MessageId {
    return this.id;
  }

  getConversationId(): ConversationId {
    return this.conversationId;
  }

  public getContent(): string {
    return this.content.getValue();
  }

  public getSender(): User {
    return this.sender;
  }

  public getStatus(): MessageStatus {
    return this.status;
  }

  public setStatus(status: MessageStatus): void {
    this.status = status;
  }

  getCreatedAt(): Date {
    return this.createdAt;
  }
}


// File: /apps/api/src/domain/messages/repositories/message.repository.ts
import { ConversationId } from "../../conversation/value-objects/conversation-id";
import { Message } from "../entities/message.entity";
import { MessageId } from "../value-objects/message-id";
import { MessageStatus } from "../value-objects/message-status";

export const MESSAGE_REPOSITORY = "MESSAGE_REPOSITORY";

export interface MessageRepository {
  save(message: Message): Promise<Message>;
  findByConversationId(conversationId: ConversationId): Promise<Message[]>;
  updateStatus(messageId: MessageId, status: MessageStatus): Promise<void>;
}


// File: /apps/api/src/domain/messages/value-objects/message-content.ts
export class MessageContent {
  private readonly value: string;
  private static readonly MAX_LENGTH = 2000;

  constructor(value: string) {
    this.validateContent(value);
    this.value = value;
  }

  private validateContent(value: string): void {
    if (!value || typeof value !== "string") {
      throw new Error("Message content must be a non-empty string");
    }

    if (value.length > MessageContent.MAX_LENGTH) {
      throw new Error(`Message content cannot exceed ${MessageContent.MAX_LENGTH} characters`);
    }

    if (value.trim().length === 0) {
      throw new Error("Message content cannot be empty or only whitespace");
    }
  }

  public getValue(): string {
    return this.value;
  }

  public equals(other: MessageContent): boolean {
    return this.value === other.value;
  }

  public toString(): string {
    return this.value;
  }
}


// File: /apps/api/src/domain/messages/value-objects/message-id.ts
export class MessageId {
  constructor(private readonly value: string) {
    if (!value) {
      throw new Error("MessageId cannot be empty");
    }
  }

  toString(): string {
    return this.value;
  }

  getValue(): string {
    return this.value;
  }

  static generate(): MessageId {
    return new MessageId(crypto.randomUUID());
  }
}


// File: /apps/api/src/domain/messages/value-objects/message-status.ts
export enum MessageStatusType {
  SENT = "SENT",
  DELIVERED = "DELIVERED",
  READ = "READ",
  FAILED = "FAILED",
}

export class MessageStatus {
  private readonly value: MessageStatusType;

  constructor(value: MessageStatusType) {
    this.validateStatus(value);
    this.value = value;
  }

  private validateStatus(value: MessageStatusType): void {
    if (!Object.values(MessageStatusType).includes(value)) {
      throw new Error("Invalid message status");
    }
  }

  public getValue(): MessageStatusType {
    return this.value;
  }

  public equals(other: MessageStatus): boolean {
    return this.value === other.value;
  }

  public toString(): string {
    return this.value;
  }

  public static create(value: string): MessageStatus {
    return new MessageStatus(value as MessageStatusType);
  }
}


// File: /apps/api/src/domain/user/entities/user.entity.ts
import { Email } from "../value-objects/email";
import { UserId } from "../value-objects/user-id";

export class User {
  constructor(
    private readonly id: UserId,
    private readonly name: string,
    private readonly email: Email,
    private readonly profilePhotoUrl?: string,
  ) {}

  getId(): string {
    return this.id.getValue();
  }

  getName(): string {
    return this.name;
  }

  getEmail(): string {
    return this.email.getValue();
  }

  getProfilePhotoUrl(): string | undefined {
    return this.profilePhotoUrl;
  }
}


// File: /apps/api/src/domain/user/repositiories/user.repository.ts
import { User } from "../entities/user.entity";
import { Email } from "../value-objects/email";
import { UserId } from "../value-objects/user-id";

export const USER_REPOSITORY = "USER_REPOSITORY";

export interface UserRepository {
  findById(id: UserId): Promise<User | null>;
  findByEmail(email: Email): Promise<User | null>;
  save(user: User): Promise<User>;
}


// File: /apps/api/src/domain/user/value-objects/email.ts
export class Email {
  constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(email: string): void {
    if (!email || email.trim().length === 0) {
      throw new Error("Email cannot be empty");
    }

    const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    if (!emailRegex.test(email)) {
      throw new Error("Invalid email format");
    }
  }

  public getValue(): string {
    return this.value;
  }

  equals(other: Email): boolean {
    return this.value.toLowerCase() === other.value.toLowerCase();
  }
}


// File: /apps/api/src/domain/user/value-objects/user-id.ts
export class UserId {
  constructor(private readonly value: string) {
    this.validate(value);
  }

  private validate(id: string): void {
    if (!id || id.trim().length === 0) {
      throw new Error("User ID cannot be empty");
    }
    // TODO: Add UUID validation if needed.
  }

  public getValue(): string {
    return this.value;
  }

  equals(other: UserId): boolean {
    return this.value === other.value;
  }
}


// File: /apps/api/src/infrastructure/auth/auth.service.ts
// @Injectable()
// export class AuthService {
//   constructor(
//     private userRepository: UserRepository,
//     private jwtService: JwtService,
//     private passwordHasher: PasswordHasher,
//   ) {}
//
//   async validateUser(email: string, password: string): Promise<User | null> {
//     const user = await this.userRepository.findByEmail(new Email(email));
//     if (!user || !(await this.passwordHasher.compare(password, user.getPasswordHash()))) {
//       return null;
//     }
//     return user;
//   }
//
//   async login(user: User) {
//     const payload = {
//       sub: user.getId(),
//       email: user.getEmail(),
//       name: user.getName(),
//     };
//
//     return {
//       access_token: this.jwtService.sign(payload),
//       user: {
//         id: user.getId(),
//         name: user.getName(),
//         email: user.getEmail(),
//         profilePhotoUrl: user.getProfilePhotoUrl(),
//       },
//     };
//   }
// }


// File: /apps/api/src/infrastructure/auth/jwt-auth.guard.ts
import { Injectable } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";

@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {}


// File: /apps/api/src/infrastructure/database/supabase/conversation.repository.ts
// src/infrastructure/database/supabase/conversation.repository.ts
import { ConversationDetailsDto, ConversationListElementDto, MemberDto } from "@chat-app/dtos";
import { Injectable, Logger } from "@nestjs/common";

import { SupabaseService } from "../../../chat/supabase.service";
import { Conversation } from "../../../domain/conversation/entities/conversation.entity";
import { ConversationRepository } from "../../../domain/conversation/repositories/conversation.repository";
import { ConversationId } from "../../../domain/conversation/value-objects/conversation-id";
import { ConversationType } from "../../../domain/conversation/value-objects/conversation-type";
import { Message } from "../../../domain/messages/entities/message.entity";
import { MessageContent } from "../../../domain/messages/value-objects/message-content";
import { MessageId } from "../../../domain/messages/value-objects/message-id";
import { MessageStatus } from "../../../domain/messages/value-objects/message-status";
import { User } from "../../../domain/user/entities/user.entity";
import { Email } from "../../../domain/user/value-objects/email";
import { UserId } from "../../../domain/user/value-objects/user-id";

interface SupabaseConversationResponse {
  conversation_id: string;
  conversation: {
    name: string;
    avatar_url: string;
    last_message: string;
    last_message_timestamp: string;
  };
  other_user: {
    users: Array<{
      id: string;
      name: string;
      email: string;
      profile_photo_url: string;
    }>;
  };
  last_message: {
    message: Array<{
      id: string;
      sender_id: string;
      content: string;
      status: string;
      created_at: string;
    }>;
  };
}

interface SupabaseMessageResponse {
  id: string;
  content: string;
  created_at: string;
  sender: {
    id: string;
    name: string;
    profile_photo_url: string | null;
  };
  conversation: {
    id: string;
  };
}

@Injectable()
export class SupabaseConversationRepository implements ConversationRepository {
  private readonly logger = new Logger(SupabaseConversationRepository.name);

  constructor(private readonly supabase: SupabaseService) {}

  async findByUserId(userId: string): Promise<Conversation[]> {
    // Fixed return type
    try {
      const { data, error } = await this.supabase.supabase
        .from("conversationuser")
        .select(
          `
        conversation_id,
        conversation:conversation_id(
          name,
          avatar_url,
          last_message,
          last_message_timestamp
        ),
        other_user:conversation_id(
          users!inner(id, name, email, profile_photo_url)
        ),
        last_message:conversation_id(
          message(id, sender_id, content, status, created_at)
        )
      `,
        )
        .eq("user_id", userId)
        .neq("other_user.users.id", userId);

      if (error) {
        this.logger.error(`Error fetching conversations: ${error.message}`);
        return [];
      }

      if (!data || data.length === 0) {
        return [];
      }

      const conversations: Conversation[] = [];

      for (const rawItem of data) {
        const item = rawItem as unknown as SupabaseConversationResponse;
        try {
          const otherUser = item.other_user.users[0];
          const lastMessageData = item.last_message?.message?.[0];

          const members = [
            new User(new UserId(userId), "Current User", new Email("user@example.com"), null),
            new User(new UserId(otherUser.id), otherUser.name, new Email(otherUser.email), otherUser.profile_photo_url),
          ];

          const conversation = new Conversation(
            new ConversationId(item.conversation_id),
            item.conversation.name,
            ConversationType.DIRECT,
            members,
            item.conversation.avatar_url,
          );

          if (lastMessageData) {
            const sender = members.find((m) => m.getId() === lastMessageData.sender_id) || members[0];
            const message = new Message(
              new MessageId(lastMessageData.id),
              sender,
              new ConversationId(item.conversation_id),
              new MessageContent(lastMessageData.content),
              MessageStatus.create(lastMessageData.status || "SENT"),
              new Date(lastMessageData.created_at),
            );
            conversation.addMessage(message);
          }

          conversations.push(conversation);
        } catch (error) {
          this.logger.error(`Error processing conversation: ${error.message}`);
          // Continue with next conversation
          continue;
        }
      }

      return conversations;
    } catch (error) {
      this.logger.error("Error fetching conversations:", error);
      return [];
    }
  }

  async findById(conversationId: ConversationId): Promise<ConversationDetailsDto> {
    try {
      const { data, error } = await this.supabase.supabase
        .from("message")
        .select(
          `
          id,
          content,
          created_at,
          sender:users(name, id, profile_photo_url),
          conversation:conversation!inner(id)
        `,
        )
        .eq("conversation_id", conversationId.getValue())
        .order("created_at", { ascending: true });

      if (error) {
        throw new Error(`Failed to fetch conversation: ${error.message}`);
      }

      const messages = data as unknown as SupabaseMessageResponse[];

      return {
        conversationId: conversationId.getValue(),
        messageList: messages.map((msg) => ({
          message_id: msg.id,
          content: msg.content,
          created_at: msg.created_at,
          sender_id: msg.sender.id,
          status: "sent",
        })),
        memberList: this.getUniqueSenders(messages),
      };
    } catch (error) {
      this.logger.error(`Error in findById: ${error.message}`);
      throw error;
    }
  }

  async getParticipants(conversationId: string): Promise<string[]> {
    try {
      const { data, error } = await this.supabase.supabase.from("conversationuser").select("user_id").eq("conversation_id", conversationId);

      if (error) {
        throw new Error(`Failed to get participants: ${error.message}`);
      }

      return data.map((row) => row.user_id);
    } catch (error) {
      this.logger.error(`Error getting participants: ${error.message}`);
      throw error;
    }
  }

  async getUserConversations(userId: string): Promise<ConversationListElementDto[]> {
    console.log("ZZZZ");
    try {
      const { data, error } = await this.supabase.supabase
        .from("conversationuser")
        .select(
          `
        conversation_id,
        conversation:conversation_id(
          name,
          avatar_url,
          last_message,
          last_message_timestamp
        ),
        other_user:conversation_id(users!inner(id, name, profile_photo_url)),
        last_message:conversation_id(
          message(sender_id)
        )
      `,
        )
        .eq("user_id", userId)
        .neq("other_user.users.id", userId)
        .order("conversation(last_message_timestamp)", { ascending: false });

      if (error) {
        return [];
      }

      if (!data || data.length === 0) {
        return [];
      }

      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const conversations: ConversationListElementDto[] = data.map((item: any) => {
        const otherUser = item.other_user.users[0];
        const lastMessage = item.last_message.message[0];

        return {
          conversationId: item.conversation_id,
          avatarUrl: otherUser?.profile_photo_url,
          name: otherUser?.name,
          lastMessageContent: item.conversation.last_message || "",
          lastMessageTimestamp: item.conversation.last_message_timestamp || "",
          lastMessageSenderId: lastMessage?.sender_id || "",
        };
      });
      return conversations;
    } catch (error) {
      return [];
    }
  }

  // async getUserConversations(userId: string): Promise<ConversationListElementDto[]> {
  //   try {
  //     const { data, error } = await this.supabase.supabase
  //       .from("conversationuser")
  //       .select(
  //         `
  //         conversation_id,
  //         conversation:conversation_id(
  //           name,
  //           avatar_url,
  //           last_message,
  //           last_message_timestamp
  //         ),
  //         other_user:conversation_id(
  //           users!inner(id, name, profile_photo_url)
  //         ),
  //         last_message:conversation_id(
  //           message(sender_id)
  //         )
  //       `,
  //       )
  //       .eq("user_id", userId)
  //       .neq("other_user.users.id", userId);
  //
  //     console.log(data);
  //
  //     if (error) {
  //       this.logger.error(`Error fetching conversations: ${error.message}`);
  //       return [];
  //     }
  //
  //     return (data || []).map((item: any) => ({
  //       conversationId: item.conversation_id,
  //       avatarUrl: item.other_user?.users[0]?.profile_photo_url || item.conversation.avatar_url,
  //       name: item.other_user?.users[0]?.name || item.conversation.name,
  //       lastMessageContent: item.conversation.last_message || "",
  //       lastMessageTimestamp: item.conversation.last_message_timestamp || "",
  //       lastMessageSenderId: item.last_message?.message[0]?.sender_id || "",
  //     }));
  //   } catch (error) {
  //     this.logger.error(`Error in getUserConversations: ${error.message}`);
  //     return [];
  //   }
  // }

  async updateLastMessage(
    conversationId: ConversationId,
    lastMessage: {
      messageId: string;
      content: string;
      senderId: string;
      timestamp: Date;
    },
  ): Promise<void> {
    try {
      const { error } = await this.supabase.supabase
        .from("conversation")
        .update({
          last_message: lastMessage.content,
          last_message_timestamp: lastMessage.timestamp.toISOString(),
          last_message_sender_id: lastMessage.senderId,
        })
        .eq("id", conversationId.getValue());

      if (error) {
        throw new Error(`Failed to update last message: ${error.message}`);
      }
    } catch (error) {
      this.logger.error(`Error updating last message: ${error.message}`);
      throw error;
    }
  }

  private getUniqueSenders(messages: SupabaseMessageResponse[]): MemberDto[] {
    return Array.from(
      new Map(
        messages.map((msg) => [
          msg.sender.id,
          {
            id: msg.sender.id,
            name: msg.sender.name,
            profile_photo_url: msg.sender.profile_photo_url,
          },
        ]),
      ).values(),
    );
  }

  async save(conversation: Conversation): Promise<void> {
    throw new Error("Method not implemented");
  }

  async update(conversation: Conversation): Promise<void> {
    throw new Error("Method not implemented");
  }
}


// File: /apps/api/src/infrastructure/database/supabase/message.repository.ts
import { Injectable } from "@nestjs/common";
import { MessageRepository } from "../../../domain/messages/repositories/message.repository";
import { Message } from "../../../domain/messages/entities/message.entity";
import { SupabaseService } from "../../../chat/supabase.service";
import { ConversationId } from "../../../domain/conversation/value-objects/conversation-id";
import { MessageId } from "../../../domain/messages/value-objects/message-id";
import { MessageStatus } from "../../../domain/messages/value-objects/message-status";

@Injectable()
export class SupabaseMessageRepository implements MessageRepository {
  constructor(private readonly supabase: SupabaseService) {}

  async save(message: Message): Promise<Message> {
    const { data } = await this.supabase.supabase
      .from("message")
      .insert({
        id: message.getId().toString(),
        conversation_id: message.getConversationId().getValue(),
        sender_id: message.getSender().getId(),
        content: message.getContent(),
        created_at: message.getCreatedAt().toISOString(),
        status: message.getStatus().getValue(),
      })
      .select()
      .single();

    return message;
  }

  async findByConversationId(conversationId: ConversationId): Promise<Message[]> {
    const { data } = await this.supabase.supabase
      .from("message")
      .select(
        `
        id,
        content,
        created_at,
        status,
        sender:sender_id(id, name, email, profile_photo_url)
      `,
      )
      .eq("conversation_id", conversationId.getValue())
      .order("created_at", { ascending: true });

    return []; // You'll need to map the data to Message entities
  }

  async updateStatus(messageId: MessageId, status: MessageStatus): Promise<void> {
    await this.supabase.supabase.from("message").update({ status: status.getValue() }).eq("id", messageId.toString());
  }
}


// File: /apps/api/src/infrastructure/database/supabase/user.repository.ts
import { Injectable } from "@nestjs/common";

import { SupabaseService } from "../../../chat/supabase.service";
import { User } from "../../../domain/user/entities/user.entity";
import { UserRepository } from "../../../domain/user/repositiories/user.repository";
import { Email } from "../../../domain/user/value-objects/email";
import { UserId } from "../../../domain/user/value-objects/user-id";

@Injectable()
export class SupabaseUserRepository implements UserRepository {
  constructor(private readonly supabase: SupabaseService) {}

  async findById(id: UserId): Promise<User | null> {
    const { data } = await this.supabase.supabase.from("users").select("*").eq("id", id.getValue()).single();

    if (!data) return null;

    return new User(new UserId(data.id), data.name, new Email(data.email), data.profile_photo_url);
  }

  async findByEmail(email: Email): Promise<User | null> {
    const { data } = await this.supabase.supabase.from("users").select("*").eq("email", email.getValue()).single();

    if (!data) return null;

    return new User(new UserId(data.id), data.name, new Email(data.email), data.profile_photo_url);
  }

  async save(user: User): Promise<User> {
    // Implementation for saving user
    return user;
  }
}


// File: /apps/api/src/interfaces/http/chat.controller.ts
import { ConversationListElementDto, ConversationDetailsDto, MessageSendDto } from "@chat-app/dtos";
import { Controller, Get, Param, Request, UseGuards, Post, Body } from "@nestjs/common";

import { ConversationService } from "../../application/services/conversation.service";
import { JwtAuthGuard } from "../../infrastructure/auth/jwt-auth.guard";

@Controller("chat")
@UseGuards(JwtAuthGuard)
export class ChatController {
  constructor(private conversationService: ConversationService) {}

  @Get("conversations")
  @UseGuards(JwtAuthGuard)
  async getConversations(@Request() req): Promise<ConversationListElementDto[]> {
    const userId = req.user.id;
    console.log("XXX");
    return await this.conversationService.getUserConversations(userId);
  }

  @Get("conversations/:conversationId")
  @UseGuards(JwtAuthGuard)
  async getConversation(@Request() req, @Param("conversationId") conversationId: string): Promise<ConversationDetailsDto> {
    const userId = req.user.id;
    return await this.conversationService.getConversationDetails(userId, conversationId);
  }

  // @Post("conversations")
  // async updateMessagesFromQueue(@Request() req, @Body("queue") queue: MessageSendDto[], @Body("conversationId") conversationId: string): Promise<any> {
  //   const userId = req.user.id;
  //   return await delayResponse(this.chatGateway.updateMessagesFromQueue(userId, conversationId, queue));
  // }
}


// File: /apps/api/src/interfaces/websocket/chat.gateway.ts
import { SendMessageRequestDto } from "@chat-app/dtos";
import { Logger } from "@nestjs/common";
import {
  ConnectedSocket,
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
  SubscribeMessage,
  WebSocketGateway,
  WebSocketServer,
} from "@nestjs/websockets";
import { Server, Socket } from "socket.io";

import { SendMessageCommand } from "../../application/commands/send-message.command";
import { CommandBus } from "@nestjs/cqrs";

@WebSocketGateway({
  cors: {
    origin: "*",
  },
})
export class ChatGateway implements OnGatewayConnection, OnGatewayDisconnect {
  @WebSocketServer() server: Server;
  private readonly logger = new Logger(ChatGateway.name);

  constructor(private readonly commandBus: CommandBus) {}

  @SubscribeMessage("sendMessage")
  async handleSendMessage(@MessageBody() dto: SendMessageRequestDto, @ConnectedSocket() client: Socket): Promise<void> {
    this.logger.log(`Handling sendMessage: ${JSON.stringify(dto)}`);
    try {
      const command = new SendMessageCommand(dto.content, dto.userId, dto.conversationId, new Date());

      await this.commandBus.execute(command);
      this.logger.log("Message sent successfully");
    } catch (error) {
      this.logger.error(`Failed to send message: ${error.message}`, error.stack);
      throw error;
    }
  }

  emitToUser(userId: string, event: string, data: any): void {
    this.server.to(`user:${userId}`).emit(event, data);
  }

  async handleConnection(client: Socket) {
    try {
      const userId = client.handshake.query.userId as string;
      if (!userId) {
        this.logger.error("User ID not provided in connection");
        client.disconnect();
        return;
      }
      client.join(`user:${userId}`);
      this.logger.log(`Client connected: ${client.id} for user: ${userId}`);
    } catch (error) {
      this.logger.error(`Error in handleConnection: ${error.message}`);
    }
  }

  handleDisconnect(client: any): any {}
}


// File: /apps/api/src/main.ts
import { NestFactory } from "@nestjs/core";

import { AppModule } from "./app.module";

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors({
    origin: "http://localhost:4200", // Your Angular app URL
    methods: ["GET", "POST", "PUT", "DELETE", "OPTIONS"],
    allowedHeaders: ["Authorization", "Content-Type"],
    credentials: true,
  });
  await app.listen(3000);
}

bootstrap();

